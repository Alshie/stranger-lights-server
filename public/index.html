<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
	<title>Stranger Lights</title>
	<script src="socket.io/socket.io.js"></script>
	<script src="Vector2.js"></script>
	<style>
	body { 
		margin:0px;
	}
	.letter {
		
		font-family : sans-serif;
		display : block; 
		background : white; 
		border : 2px black solid;
		border-radius : 8px;  
		width : 70px; 
		height : 70px; 
		float : left;
		text-align:center;
		margin:1em;
		padding-top:1.5em;
		padding-bottom:0em;
	} 
	#button {	
		color : red;
		font-family : sans-serif;
		display : block; 
		background : rgba(0,0,0,0.4); 
		border : none; 
		border-radius : 8px;  
		
		width:12em;
		
		padding : 1em;
		text-align:center;
		margin:1em;
		padding-top:1em;
		padding-bottom:1em;
	
		position:absolute;
			
		
	}
	#outputText { 
		position:absolute;
		font-family : sans-serif;
		margin:2em; 
		color : #cccccc;
		pointer-events : none;
		
	}
	</style>
  </head>
  <body>
	
	<span id="button" onclick="requestControl()">Request control</span>
	<span id="outputText" ></span>
	<script src="lightcolours.js"></script>
	<script type="text/javascript">



var name = ''; 
var queue = []; 
var roomList = []; 
var inControl = false; 
var currentControllerName; 
var mouseX = 0, mouseY = 0, lastMouseX, lastMouseY, mouseDown = false, lastMouseSent = 0; 
var pointerImg = new Image(); 
	pointerImg.src = 'pointer.png'; 
var pointer = new RemotePointer(pointerImg); 

var background = new Image(); 
	background.src = 'wallbackground.jpg'; 
var nextChangeTime = 0; 
var canvas = document.createElement('canvas'); 
var ctx = canvas.getContext('2d');
var dirty = true; 

var room = getQueryVariable("room") || "default";

var socket = initSocket(); 

var outputTextDom = document.getElementById('outputText'); 

var lights = [];
var lightsById = {}; 


window.addEventListener('load', initialise); 
window.addEventListener('resize', onResize); 

var lightRects = [{"x":302.5,"y":133,"w":155,"h":232},{"x":495.5,"y":142.5,"w":142.5,"h":222.5},{"x":658.5,"y":155,"w":123.5,"h":218.5},{"x":814.5,"y":168.5,"w":140,"h":228},{"x":970.5,"y":165.5,"w":155,"h":235},{"x":1144.5,"y":201,"w":116.5,"h":194},{"x":1273.5,"y":212,"w":123.5,"h":190},{"x":1422.5,"y":198,"w":123.5,"h":205},{"x":54.5,"y":321.5,"w":190,"h":312},{"x":343.5,"y":411.5,"w":161.5,"h":243},{"x":528,"y":430.5,"w":144,"h":247},{"x":691,"y":453.5,"w":150.5,"h":226.5},{"x":851,"y":459,"w":135.5,"h":218.5},{"x":996.5,"y":425,"w":119.5,"h":221.5},{"x":1133.5,"y":400.5,"w":118,"h":252.5},{"x":1276,"y":414,"w":140,"h":245.5},{"x":1535.5,"y":425,"w":186,"h":264.5},{"x":229.5,"y":655.5,"w":160,"h":264.5},{"x":403,"y":688,"w":144,"h":241.5},{"x":560.5,"y":716.5,"w":116.5,"h":225.5},{"x":722,"y":726,"w":134.5,"h":217},{"x":879.5,"y":723.5,"w":141,"h":195.5},{"x":1035.5,"y":716.5,"w":135.5,"h":237.5},{"x":1182.5,"y":712.5,"w":119.5,"h":224},{"x":1315.5,"y":704.5,"w":145,"h":229.5},{"x":1490.5,"y":697.5,"w":180.5,"h":233.5}];
	
var bulbPositions = [{"x":400.5,"y":167},{"x":559.5,"y":174},{"x":683,"y":194},{"x":890.5,"y":228},{"x":1004.5,"y":232},{"x":1219,"y":282.5},{"x":1341,"y":259.5},{"x":1483.5,"y":258},{"x":171,"y":387},{"x":421,"y":461.5},{"x":570,"y":488.5},{"x":737,"y":509},{"x":904,"y":510},{"x":1029,"y":475},{"x":1183.5,"y":449.5},{"x":1323.5,"y":460},{"x":1622,"y":495.5},{"x":292,"y":699},{"x":452,"y":738.5},{"x":582.5,"y":779},{"x":783.5,"y":772.5},{"x":936.5,"y":778},{"x":1082.5,"y":760},{"x":1211,"y":755},{"x":1371,"y":738.5},{"x":1587,"y":756}]

var rotations = [
	-35, 	// A
	-55,	// B
	8, 		// C
	10,		// D
	-35, 	// E
	-30,	// F
	-65, 	// G
	-25,	// H
	5, 		// I
	0, 		// J
	-20,	// K
	8,		// L
	-10,		// M
	-8, 	// N
	-12,	// O
	-13,	// P
	13,		// Q
	2, 		// R
	20,		// S
	8, 		// T
	-60,	// U
	5, 		// V
	0, 		// W
	-30, 		// X
	0, 		// Y
	-10 		// Z

]; 


function initialise() { 
	
	initInterface(); 
	
	// start update cycle (it calls itself with rAF)
	update(); 
	//setInterval(update, 1000/60); 
	

	
}


function initInterface() { 


	document.body.appendChild(canvas); 
	onResize(); 
	
	canvas.addEventListener('mousemove', canvasMouseMove); 
	canvas.addEventListener('mousedown', canvasMouseDown); 
	canvas.addEventListener('mouseup', canvasMouseUp);
	canvas.addEventListener('mouseout', canvasMouseUp);	
	var letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
	

	
	for(var i = 0; i<letters.length; i++) { 
	
		var letter =  letters[i]; 
		var light = new Light(lightRects[i], letter, bulbPositions[i], colours[lightColours[i]]); 
		if(rotations.length>i) light.rotation = rotations[i]; 
		lights.push(light); 
		lightsById[letter] = light;
		
	}
	
	
}

function update() { 
	if(inControl) { 
		if(Date.now()-lastMouseSent>100) { 
			if((lastMouseX!=mouseX) || (lastMouseY!=mouseY)) {
				socket.emit('mouse', {x:mouseX, y:mouseY});
			}
		
			lastMouseX = mouseX; 
			lastMouseY = mouseY;
			lastMouseSent = Date.now(); 
		} 
	}

	updateDisplay(); 
	
	window.requestAnimationFrame(update);

}



function updateDisplay() { 
	
	for(var i = 0; i<lights.length; i++) { 
		if(lights[i].update()) dirty = true; 
	}
	
	if(pointer.update()) dirty = true; 
	
	if(dirty) { 
		ctx.save();
		var s = canvas.width/background.width;  
		ctx.scale(s,s); 
		ctx.drawImage(background, 0,0); 
	
		ctx.strokeStyle = 'yellow'; 
		ctx.fillStyle = 'white'; 
		ctx.lineWidth = 5; 
		for(var i = 0; i<lights.length; i++) { 
			var l = lights[i]; 
			l.render(ctx); 
		
		}

		pointer.render(ctx);

		ctx.restore(); 
	} else { 
		
		ctx.fillStyle = 'red'; 
		ctx.fillRect(10,10,10,10); 
	}
	// TODO store text in a string and compare before updating dom element
	var oldText = outputTextDom.innerHTML; 
	
	var newText = ""; 

	var changeTime = Math.ceil(((nextChangeTime-Date.now())/1000));
	
	
	if(inControl) { 
		
		if(changeTime<=10) { 
			if(Date.now()%500<300) { 
				newText = "<b>"+changeTime+" SECOND"+(changeTime!=1?"S":"")+" LEFT!"; 
			}
		} else {
			newText+="You are now in control"; 
		}
		
	} else { 
		newText = "Connected as <b>"+socket.name+"</b>"; 
		if(currentControllerName) newText+="<br>"+currentControllerName+" is currently in control"; 
	
		newText+="<br>";
		
		if((changeTime>0) && (changeTime<19)) {
			newText+="Next change in "+changeTime;
		}
		if(queue.length>0) { 
			newText+="<br><br>Waiting list :";
			for (var i = 0; i<queue.length; i++) { 
				var qname = queue[i]; 
				if(qname==name) {
					newText+="<br>"
					if(i==0) { 
						if((changeTime>10) || (Date.now()%500<300)) newText +="<b>> "+qname+" < YOU'RE UP NEXT! </b>";
					} else { 
						newText +="<b>> "+qname+" <</b> you ";
					}
				} else { 
					newText+="<br>" + qname;
 				}
					
			}
		}
		newText+='<br clear="all">';
	}

		
	if(newText!=oldText) { 
		outputTextDom.innerHTML = newText; 
	} 
	dirty = false; 
}

function onResize(){ 
	canvas.width = window.innerWidth; 
	canvas.height = window.innerWidth*background.height/background.width;
	button.style.left = (canvas.width - button.offsetWidth*1.1)+'px'; 
	dirty = true; 
}




function Light(rect, letter, bulbpos, bulbColour) { 
	
	var rect = this.rect = rect; 
	this.letter = letter; 
	this.bulbPosition = bulbpos; 
	this.bulbColour = bulbColour; 
	this.lightOn = false; 
	this.rotation = 0;
	this.brightness = 0; 
	var lastBrightness = 1; 
	var dirty = true; 
	
	this.update = function() { 
		
		if(this.lightOn) { 
			this.brightness+=((1-this.brightness))*0.85; 
			if(Math.abs(1-this.brightness)<0.001) this.brightness = 1; 
		} else { 
			this.brightness*=0.6; 
			if(this.brightness<0.001) this.brightness = 0;
		}
		
		dirty = this.brightness!=lastBrightness; 
		lastBrightness = this.brightness; 
		return dirty; 
		
	}
	this.render = function(ctx) { 
		
		if(this.brightness>0) { 
		
			var b = this.bulbPosition; 
			
			var h = bulbColour.h; 
			var s = bulbColour.s; 
			var l = bulbColour.l; 
			
			ctx.save(); 
			ctx.globalAlpha = map(this.brightness,0,0.3,0,1, true); 
			ctx.fillStyle = hsl(h, s, l); 
			ctx.globalCompositeOperation = 'lighter'; 
			ctx.translate(b.x, b.y); 
		
			var TORAD = Math.PI/180; 
		
			ctx.beginPath(); 
			ctx.save(); 
			ctx.rotate(Math.PI/180 * this.rotation); 
			ctx.scale(0.5,1); 
			ctx.arc(0,0,17.5,TORAD*225,TORAD*315,true); 
			ctx.fill();
			ctx.restore();
		
			ctx.rotate(Math.PI/180 * this.rotation); 
			ctx.scale(1,0.9); 
			var b = map(Math.sin(Date.now()/20)+Math.random(), -1,2,0.98,1)*this.brightness;
			ctx.globalAlpha = map(b,0,1,0.6,0.9); 
			ctx.scale(b, b); 
		
			var g = ctx.createRadialGradient(0,0,0,0,0,200); 
			g.addColorStop(0,hsla(h,s,100,1)); 
			g.addColorStop(0.07,hsla(h,s,100,1)); 
			g.addColorStop(0.15,hsla(h,s,l,1));
			g.addColorStop(0.4,hsla(h,s,l,0.2));
			g.addColorStop(1,hsla(h,s,l,0));
			ctx.fillStyle = g; 
			ctx.beginPath();
			ctx.arc(0,0,200,0,Math.PI*2,true); 
			ctx.fill();
		
			ctx.restore(); 
		
		}
		
	}
	
	this.mouseDown = function(p) { 

		socket.emit('letter', { letter:this.letter, type:'on', time:Date.now() });
		this.lightOn = true; 

	}

	this.mouseUp = function(p) { 

	 	socket.emit('letter', { letter:this.letter, type:'off', time:Date.now() });
		this.lightOn = false;
		
	}
	
	this.hitTest = function(x,y) { 
		if((x<rect.x) || (x>rect.x+rect.w) ) return false; 
		else if((y<rect.y) || (y>rect.y+rect.h) ) return false; 
		else return true; 
	}
		
}
function canvasMouseMove(e) {
	
	var s = background.width/canvas.width; 

	mouseX = (e.offsetX)*s; 
	mouseY = (e.offsetY)*s;

	if(!inControl) return; 

	for(var i = 0; i<lights.length; i++)  { 
		var l = lights[i]; 
		if((l.lightOn) && (!l.hitTest(mouseX, mouseY))) { 
			l.mouseUp(); 
		}
		else if((mouseDown) && (!l.lightOn) && (l.hitTest(mouseX, mouseY))) {
			l.mouseDown(); 
		}
		
	}


}

function canvasMouseDown(e) { 
	// var s = background.width/canvas.width;
	// 	p = {x:Math.round(e.clientX*s), y:Math.round(e.clientY*s)};
	// 	console.log(p); 
	mouseDown = true; 

	e.preventDefault();
	if(!inControl) return; 

	for(var i = 0; i<lights.length; i++)  { 

		var l = lights[i]; 
		if(l.hitTest(mouseX, mouseY)) { 
			l.mouseDown(); 
		}
		
	}


}
function canvasMouseUp(e) { 
	mouseDown = false; 

	if(!inControl) return; 
	
	for(var i = 0; i<lights.length; i++)  { 
		var l = lights[i]; 
		
		if(l.lightOn) l.mouseUp(); 


	}	
}



function initSocket() { 
	var socket = io.connect();

	socket.on('led', function (data) {
	
	});
	socket.on('connect', function() { 
		socket.emit('register', {type:'sender', room:room}); 
	});
	socket.on('registered', function(data) { 
		console.log('registered', data); 
		socket.name = name = data.name;
		socket.timeOffset =  data.time - Date.now();
		
		setControl(false);
		updateDisplay();
	});
	
	socket.on('control', function(state) { 
		console.log('control', state); 
		// outputTextDom.innerHTML = "control : "+state;
		setControl(state); 
		updateDisplay(); 
	
	});
	function setControl(state) { 
		inControl = state;
		button.innerText=inControl?"Currently communicating" : "Let me try";
	}
	socket.on('letter', function(data) { 
		var l = lightsById[data.letter];
		if(l) {
			l.lightOn = data.type=='on'; 
		} 
	});
	socket.on('mouse', function(data) { 
		if(!inControl) pointer.setPosition(data.x, data.y); 
	});
	
	socket.on('status', function(data) { 
		nextChangeTime = data.queueShiftTime + socket.timeOffset; 
		queue = data.queue; 
		currentControllerName = data.currentControllerName; 
		lastStatus = data; 
	});
	
	return socket; 
}


function RemotePointer(img) { 
	
	var lastUpdate = 0; 
	var targetPos = new Vector2(0,0); 
	var pos = new Vector2(0,0); 
	var vel = new Vector2(0,0); 
	var lastPos = new Vector2(-1,-1); 
	var alpha = 1; 
	
	this.update = function() { 
		
	
		var lastAlpha = alpha; 
		
		if(Date.now()-lastUpdate > 3000) { 
			alpha = map(Date.now()-lastUpdate, 3000,6000,1,0, true); 
		} else { 
			if(alpha<1) { 
				alpha+=0.1; 
				if(alpha>1) alpha = 1; 
			}
		}
		
		
		var diff = targetPos.minusNew(pos); 
		vel.multiplyEq(0.5); 
		diff.multiplyEq(0.1); 
		vel.plusEq(diff); 
		pos.plusEq(vel); 
		
		if((pos.isCloseTo(targetPos,0.1))&&(vel.isMagLessThan(0.1))) {
			pos.copyFrom(targetPos); 
			vel.reset(0,0); 
		}
		
		var dirty =  (!lastPos.isCloseTo(pos, 0.1)) || (lastAlpha!=alpha); 
		lastPos.copyFrom(pos); 
		
		return dirty; 
	}
	this.render = function(ctx) {
		var s = background.width/canvas.width*0.8;  
		ctx.save(); 
		ctx.globalAlpha = alpha; 
		ctx.translate(pos.x, pos.y); 
		ctx.scale(s, s); 
		ctx.drawImage(img, 0,0);
		ctx.restore(); 
	}
	
	this.setPosition = function(x,y) { 
		targetPos.reset(x,y); 
		lastUpdate = Date.now(); 
	
	}
	
	
	
}

function requestControl() { 
	console.log('request control'); 
	if(!inControl) { 
		socket.emit('joinqueue'); 
		button.innerText="Control Requested"; 
	}
}


function rgb(r, g, b) { return 'rgb('+clamp(Math.round(r),0,255)+', '+clamp(Math.round(g),0,255)+', '+clamp(Math.round(b),0,255)+')';};
function rgba(r, g, b, a) { return 'rgba('+clamp(Math.round(r),0,255)+', '+clamp(Math.round(g),0,255)+', '+clamp(Math.round(b),0,255)+', '+clamp(a,0,1)+')';};
function hsl(h, s, l) { return 'hsl('+h+', '+clamp(s,0,100)+'%, '+clamp(l,0,100)+'%)';};
function hsla(h, s, l, a) { return 'hsla('+h+', '+clamp(s,0,100)+'%, '+clamp(l,0,100)+'%, '+clamp(a,0,1)+')';};


function map(value, min1, max1, min2, max2, clampResult) { 
	var returnvalue = ((value-min1) / (max1 - min1) * (max2-min2)) + min2; 
	if(clampResult) return clamp(returnvalue, min2, max2); 
	else return returnvalue; 
};

function clamp(value, min, max) { 
	if(max<min) { 
		var temp = min; 
		min = max; 
		max = temp; 
	}
	return Math.max(min, Math.min(value, max)); 
};
function getQueryVariable(variable)
{
       var query = window.location.search.substring(1);
console.log(query); 
       var vars = query.split("&");
       for (var i=0;i<vars.length;i++) {
               var pair = vars[i].split("=");
console.log(pair);
               if(pair[0] == variable){return pair[1];}
       }
       return(false);
}		
	</script>
  </body>
</html>
